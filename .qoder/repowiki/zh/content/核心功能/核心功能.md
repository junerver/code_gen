# 核心功能

<cite>
**本文档引用的文件**  
- [useChat.ts](file://app\composables\useChat.ts) - *重构：通过依赖注入解耦会话管理*
- [conversation.ts](file://app/stores/conversation.ts) - *重构：作为独立的会话存储仓库*
- [pinia-conv-repos.ts](file://app/utils/pinia-conv-repos.ts) - *新增：IConversationRepository接口的Pinia适配器*
- [conv-repos.ts](file://app/types/conv-repos.ts) - *新增：定义会话仓库的契约接口*
- [ModelSelect.vue](file://app/components/ModelSelect.vue) - *新增模型选择组件*
- [CodePreview.vue](file://app/components/CodePreview.vue)
- [id.ts](file://shared/utils/id.ts)
- [code.ts](file://shared/utils/code.ts)
- [chat.post.ts](file://server/api/chat.post.ts) - *集成MCP工具与模板生成功能*
- [pages/chat/index.vue](file://app/pages/chat/index.vue) - *聊天页面UI，使用useChat组合式函数*
</cite>

## 更新摘要
**变更内容**  
- `useChat.ts` 重构为支持依赖注入，通过 `IConversationRepository` 接口与会话管理解耦
- 新增 `pinia-conv-repos.ts` 作为 `IConversationRepository` 的具体实现，适配 Pinia Store
- 新增 `conv-repos.ts` 定义会话仓库的契约接口 `IConversationRepository`
- `conversation.ts` 重命名为 `useConversationStore`，专注于状态管理，不再包含业务逻辑
- `useChat.ts` 不再直接导入 `conversation.ts`，而是通过接口依赖注入
- 相应更新智能代码生成流程与功能协作流程图，反映新的依赖关系

## 目录
1. [项目结构分析](#项目结构分析)
2. [智能代码生成流程](#智能代码生成流程)
3. [会话管理机制](#会话管理机制)
4. [AI提示词构造逻辑](#ai提示词构造逻辑)
5. [代码预览与实时渲染](#代码预览与实时渲染)
6. [功能协作与用户流程](#功能协作与用户流程)
7. [核心状态与数据流](#核心状态与数据流)
8. [错误处理与异常恢复](#错误处理与异常恢复)

## 项目结构分析

本项目采用基于 Nuxt 3 的模块化架构，核心功能分布在 `app`、`server` 和 `shared` 三个主要目录中。前端组件与组合式函数位于 `app` 目录，后端 API 位于 `server` 目录，跨平台共享逻辑位于 `shared` 目录。关键变化是引入了依赖注入和接口抽象，使 `useChat.ts` 与 `conversation.ts` 解耦。

```
graph TB
subgraph "前端 (app)"
A[components/CodePreview.vue] --> B[composables/useChat.ts]
B --> C[stores/conversation.ts]
D[pages/chat/index.vue] --> B
E[components/ModelSelect.vue] --> B
F[utils/pinia-conv-repos.ts] --> B
end
subgraph "后端 (server)"
G[api/chat.post.ts] --> H[core/tools/mcp-tools.ts]
G --> I[core/prompt/template-gen.ts]
end
subgraph "共享 (shared)"
J[utils/code.ts] --> A
K[utils/id.ts] --> B & C
L[types/model.ts] --> E
end
B --> G
```

**图示来源**  
- [useChat.ts](file://app\composables\useChat.ts)
- [conversation.ts](file://app/stores/conversation.ts)
- [pinia-conv-repos.ts](file://app/utils/pinia-conv-repos.ts)
- [ModelSelect.vue](file://app/components/ModelSelect.vue)
- [CodePreview.vue](file://app/components/CodePreview.vue)
- [code.ts](file://shared/utils/code.ts)
- [id.ts](file://shared/utils/id.ts)
- [chat.post.ts](file://server/api/chat.post.ts)
- [mcp-tools.ts](file://server/core/tools/mcp-tools.ts)

## 智能代码生成流程

`useChat.ts` 是驱动智能代码生成的核心组合式函数，负责协调用户输入、AI 请求、流式响应处理和消息更新。现已通过依赖注入与会话管理解耦，提高了可测试性和灵活性。

### 核心方法
- **sendMessage**: 发送用户消息并触发 AI 响应
- **generateResponse**: 处理流式 API 响应并逐步更新消息
- **addUserMessage**: 添加用户消息并自动设置会话标题
- **addAssistantMessage**: 创建助手消息占位符
- **updateAssistantMessage**: 实时更新生成的代码内容
- **selectedModel**: 响应式状态，存储当前选中的AI模型ID

```
sequenceDiagram
participant 用户
participant useChat as useChat.ts
participant repository as IConversationRepository
participant API[/api/chat]
participant AI[AI 服务]
用户->>useChat : 输入“创建一个按钮组件”
useChat->>repository : addUserMessage()
repository-->>useChat : 成功
useChat->>repository : addAssistantMessage()
repository-->>useChat : 助手消息ID
useChat->>API : fetch POST /api/chat
API->>AI : 转发请求与template-gen.ts提示词
AI-->>API : 流式返回data : {type : text-delta, delta : "..."}
API-->>useChat : 流式响应
loop 每个数据块
useChat->>useChat : 解析JSON并提取delta
useChat->>repository : updateAssistantMessage(accumulatedContent)
end
useChat-->>用户 : 实时显示生成的代码
```

**图示来源**  
- [useChat.ts](file://app\composables\useChat.ts#L200-L350)
- [pinia-conv-repos.ts](file://app/utils/pinia-conv-repos.ts)
- [chat.post.ts](file://server/api/chat.post.ts)

**本节来源**  
- [useChat.ts](file://app\composables\useChat.ts)
- [pinia-conv-repos.ts](file://app/utils/pinia-conv-repos.ts)

## 会话管理机制

`conversation.ts` 现在通过 `useConversationStore` 导出，使用 Pinia 状态管理库实现多会话的增删改查功能，维护会话列表、活跃会话和消息映射。其核心逻辑被抽象为 `IConversationRepository` 接口，供 `useChat.ts` 依赖。

### 核心数据结构
```typescript
interface Conversation {
  id: string;
  title: string;
  group: string;
  createdAt: Date;
  updatedAt: Date;
  lastMessage?: string;
  config?: any;
}

interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: Date;
  typing?: boolean | { step: number; interval: number; suffix: string };
  isMarkdown: boolean;
  shape: string;
  loading?: boolean;
  reasoningContent?: string;
  reasoningStatus?: 'start' | 'thinking' | 'end';
}
```

### 核心方法
- **createConversation**: 创建新会话并设为活跃
- **setActiveConversation**: 切换活跃会话
- **addMessage**: 添加消息并更新会话元信息
- **updateMessage**: 更新消息内容和状态
- **deleteConversation**: 删除会话并自动切换
- **clearMessages**: 清空指定会话消息

```
flowchart TD
Start([开始]) --> CheckActive{是否有活跃会话?}
CheckActive --> |否| CreateDefault[createConversation()]
CheckActive --> |是| AddMessage[addMessage()]
AddMessage --> UpdateLastMsg[更新会话lastMessage]
AddMessage --> UpdateTime[更新updatedAt]
UpdateTime --> End([结束])
```

**图示来源**  
- [conversation.ts](file://app/stores/conversation.ts#L50-L300)
- [pinia-conv-repos.ts](file://app/utils/pinia-conv-repos.ts)

**本节来源**  
- [conversation.ts](file://app/stores/conversation.ts)
- [pinia-conv-repos.ts](file://app/utils/pinia-conv-repos.ts)

## AI提示词构造逻辑

`template-gen.ts` 定义了发送给 AI 模型的系统提示词，结合MCP工具实现基于模板的代码生成，确保生成的代码符合项目技术栈规范。

### 提示词核心要求
- 技术栈：Vue3.5 + JavaScript + Element Plus
- 使用 `<script setup>` 语法糖
- 遵循 Composition API 最佳实践
- 包含完整 JSDoc 注释
- 实现错误处理与性能优化
- 代码结构：template → script → style
- 显示导入组件和 Vue API
- 不使用样式预处理器，使用原生 CSS
- 用 markdown 代码块包裹输出
- 集成MCP工具进行模板化生成

```typescript
// server/core/prompt/template-gen.ts
const templateGenPrompt = () => {
  return `
你是一个专业的前端开发专家，专门负责生成高质量的Vue3 UI组件代码。
...
请结合MCP工具和预设模板，生成完整、可直接使用的Vue3组件代码，生成的代码使用 markdown 代码块格式包裹（\`\`\`vue）
`;
};
```

该提示词在 `server/api/chat.post.ts` 中与用户消息组合后发送给 AI 服务。

**本节来源**  
- [template-gen.ts](file://server/core/prompt/template-gen.ts)
- [mcp-tools.ts](file://server/core/tools/mcp-tools.ts)

## 代码预览与实时渲染

`CodePreview.vue` 组件使用 `@vue/repl` 在浏览器中实时预览生成的 Vue 组件，无需本地构建。

### 核心依赖
- **@vue/repl**: Vue 官方在线 REPL 组件
- **Monaco**: 代码编辑器
- **buildHeadHtml**: 注入 Element Plus CSS
- **buildElementPlusSetup**: 动态加载 Element Plus
- **buildPlaygroundMain**: 构建预览主入口

### 预览流程
1. 接收生成的组件代码
2. 构建完整的项目文件结构
3. 配置 import-map 加载依赖
4. 在对话框中渲染 REPL 环境

```
flowchart TD
A[openDialog(code)] --> B[componentCode.value = code]
B --> C[dialogVisible = true]
C --> D[watch componentCode]
D --> E[store.setFiles()]
E --> F[设置App.vue, element-plus.js等]
F --> G[store.mainFile = PlaygroundMain.vue]
G --> H[Repl组件渲染]
H --> I[实时预览]
```

**图示来源**  
- [CodePreview.vue](file://app/components/CodePreview.vue)
- [code.ts](file://shared/utils/code.ts)

**本节来源**  
- [CodePreview.vue](file://app/components/CodePreview.vue)
- [code.ts](file://shared/utils/code.ts)

## 功能协作与用户流程

各组件协同工作，实现从用户输入到代码预览的完整闭环。新增模型选择功能和模板工具。

### 用户场景：创建按钮组件（支持模型选择）
1. 用户在聊天界面选择"Qwen/Qwen3-Coder-30B-A3B-Instruct"模型
2. 用户输入“创建一个按钮组件”
3. `useChat.sendMessage()` 被调用，携带选中模型
4. `conversation.addUserMessage()` 保存用户消息
5. `useChat.generateResponse()` 调用 `/api/chat` 并传递模型参数
6. 服务端使用 `template-gen.ts` 提示词和MCP工具生成请求
7. AI 流式返回代码片段
8. `useChat` 逐步调用 `updateAssistantMessage()`
9. 用户看到代码逐行生成的动画效果
10. 生成完成后，用户点击“预览”按钮
11. `CodePreview.openDialog()` 被调用
12. `@vue/repl` 渲染组件，实时预览效果

```
stateDiagram-v2
[*] --> 用户输入
用户输入 --> 选择模型 : selectModel()
选择模型 --> 发送消息 : sendMessage()
发送消息 --> 添加用户消息 : addUserMessage()
添加用户消息 --> 创建助手占位 : addAssistantMessage()
创建助手占位 --> 调用API : fetch /api/chat
调用API --> 流式接收 : reader.read()
流式接收 --> 更新消息 : updateAssistantMessage()
更新消息 --> 显示代码 : UI更新
流式接收 --> 完成? : done
完成? --> |否| 流式接收
完成? --> |是| 生成完成
生成完成 --> 等待操作
等待操作 --> 预览代码 : openDialog()
预览代码 --> 显示REPL : Repl组件渲染
显示REPL --> [*]
```

**图示来源**  
- [useChat.ts](file://app\composables\useChat.ts)
- [conversation.ts](file://app/stores/conversation.ts)
- [CodePreview.vue](file://app/components/CodePreview.vue)
- [ModelSelect.vue](file://app/components/ModelSelect.vue)

## 核心状态与数据流

系统通过 Pinia 集中管理核心状态，确保数据一致性。

### 状态映射
```typescript
const conversations = ref<Conversation[]>([]); // 所有会话列表
const activeConversationId = ref<string>(''); // 当前活跃会话ID
const conversationMessages = ref<Map<string, ChatMessage[]>>(); // 会话ID -> 消息列表
const messages = computed(() => activeMessages); // 当前会话消息（只读）
```

### ID 生成机制
使用时间戳和随机字符串确保全局唯一性：

```typescript
// shared/utils/id.ts
const generateId = (prefix: string): string => {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

export const generateMessageId = (): string => {
  return generateId('msg');
};

export const generateConversationId = (): string => {
  return generateId('conv');
};
```

**本节来源**  
- [conversation.ts](file://app/stores/conversation.ts)
- [id.ts](file://shared/utils/id.ts)

## 错误处理与异常恢复

系统在多个层级实现了健壮的错误处理机制。

### 前端错误处理
- **网络请求失败**: 捕获 fetch 异常，设置 error 状态
- **流式解析失败**: try-catch 包裹 JSON 解析
- **空响应处理**: 删除空的助手消息或标记完成
- **状态恢复**: finally 块确保 loading 状态重置

```typescript
try {
  await generateResponse(assistantMessageId);
} catch (err) {
  error.value = err instanceof Error ? err.message : '发送消息失败';
  // 清理残留的空消息
  if (lastMessage?.role === 'assistant' && lastMessage.content === '') {
    conversationStore.deleteMessage(convId, lastMessage.id);
  }
} finally {
  loading.value = false;
}
```

### 后端错误处理
- API 层验证请求体
- 流式响应错误通过 HTTP 状态码返回
- 服务端日志记录异常信息

**本节来源**  
- [useChat.ts](file://app\composables\useChat.ts#L280-L320)
- [conversation.ts](file://app/stores/conversation.ts)