# 开发者指南

<cite>
**本文档中引用的文件**  
- [store.ts](file://app\composables\store.ts) - *原有可组合函数*
- [useChat.ts](file://app\composables\useChat.ts) - *已重构，支持依赖注入*
- [conversation.ts](file://app\stores\conversation.ts) - *Pinia 会话状态管理*
- [conv-repos.ts](file://app\types\conv-repos.ts) - *新增：会话仓库接口*
- [pinia-conv-repos.ts](file://app\utils\pinia-conv-repos.ts) - *新增：Pinia 适配器实现*
- [chat.ts](file://app\types\chat.ts) - *消息类型定义*
- [conversation.ts](file://app\types\conversation.ts) - *会话类型定义*
- [chat.post.ts](file://server\api\chat.post.ts) - *后端 API*
- [ai-gen.ts](file://shared\prompt\ai-gen.ts) - *AI 提示模板*
- [code.ts](file://shared\utils\code.ts) - *共享代码工具*
- [id.ts](file://shared\utils\id.ts) - *共享 ID 工具*
- [string.ts](file://shared\utils\string.ts) - *共享字符串工具*
- [format.ts](file://server\utils\format.ts) - *服务端格式化工具*
- [nuxt.config.ts](file://nuxt.config.ts) - *Nuxt 配置*
- [eslint.config.mjs](file://eslint.config.mjs) - *代码规范配置*
</cite>

## 更新摘要
**变更内容**   
- 更新了“如何新增可组合函数”和“架构概览”部分，以反映 `useChat` 与会话管理的解耦重构
- 新增了“会话仓库模式”章节，介绍 `IConversationRepository` 接口和 `PiniaConversationRepository` 适配器
- 更新了“核心组件”和“详细组件分析”中的相关描述
- 修正了“依赖分析”中的依赖关系图
- 更新了所有受影响的文件来源注释，标记了新增和修改的文件

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概览](#架构概览)
5. [详细组件分析](#详细组件分析)
6. [依赖分析](#依赖分析)
7. [性能考量](#性能考量)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介
本指南旨在为二次开发者提供全面的技术支持，帮助其扩展和定制本项目。内容涵盖新增可组合函数、利用共享工具函数提升开发效率、扩展提示模板、添加前后端新功能、类型安全实践以及代码贡献规范。项目基于 Nuxt 框架构建，采用模块化设计，前后端分离，支持 AI 代码生成与对话管理。**特别说明**：近期对 `useChat` 可组合函数进行了重构，解耦了其与具体会话管理实现的依赖，引入了新的会话仓库模式，以增强可测试性和可扩展性。

## 项目结构
项目采用典型的 Nuxt 3 分层架构，结合共享逻辑与服务端处理，整体结构清晰，职责分明。

``mermaid
graph TB
subgraph "前端 (app)"
A[components] --> |UI 组件| B[CodePreview.vue]
C[composables] --> |可组合函数| D[store.ts, useChat.ts]
E[pages] --> |页面路由| F[index.vue, chat/index.vue]
G[stores] --> |状态管理| H[conversation.ts]
I[types] --> |类型定义| J[chat.ts, conversation.ts, conv-repos.ts]
K[utils] --> |前端工具| L[dependency.ts, encode.ts, pinia-conv-repos.ts]
end
subgraph "服务端 (server)"
M[api] --> |API 接口| N[chat.post.ts]
O[utils] --> |服务端工具| P[format.ts, model.ts]
Q[core/steps/design-component] --> |核心处理| R[index.ts]
end
subgraph "共享模块 (shared)"
S[prompt] --> |提示模板| T[ai-gen.ts, template-gen.ts]
U[utils] --> |通用工具| V[code.ts, id.ts, string.ts]
end
B --> F
D --> F
H --> D
J --> D
L --> D
N --> R
T --> R
V --> R
P --> R
```

**图示来源**
- [app](file://app#L1-L5)
- [server](file://server#L1-L5)
- [shared](file://shared#L1-L5)

**本节来源**
- [README.md](file://README.md#L1-L37)

## 核心组件

### 可组合函数（Composables）
位于 `app/composables/` 目录，提供跨组件复用的逻辑。

- **store.ts**：封装全局状态访问逻辑，集成 Pinia store。
- **useChat.ts**：核心聊天逻辑，管理对话流程、消息发送与接收。**已重构**：通过依赖注入 `IConversationRepository` 接口，解耦了与具体状态管理实现的耦合。

### 类型定义（Types）
位于 `app/types/`，定义关键数据结构，确保类型安全。

- **chat.ts**：定义 `Message`、`ChatState` 等接口。
- **conversation.ts**：定义 `Conversation` 结构，包含 ID、标题、消息列表等。
- **conv-repos.ts**：**新增**：定义 `IConversationRepository` 接口，抽象会话和消息的存储与管理操作。

### 状态管理（Stores）
- **conversation.ts**：使用 Pinia 管理对话状态，支持创建、切换、删除会话。

### 服务端 API
- **chat.post.ts**：处理 `/api/chat` POST 请求，调用 AI 生成逻辑。
- **core/steps/design-component/index.ts**：核心 AI 代码生成步骤，解析需求并生成代码。

### 共享工具与提示
- **shared/utils**：提供 `id.ts`（生成唯一 ID）、`string.ts`（字符串处理）、`code.ts`（代码相关操作）。
- **shared/prompt**：包含 `ai-gen.ts`（AI 生成主提示）、`template-gen.ts`（模板生成提示）。

**本节来源**
- [store.ts](file://app\composables\store.ts#L1-L50)
- [useChat.ts](file://app\composables\useChat.ts#L1-L80)
- [chat.ts](file://app\types\chat.ts#L1-L40)
- [conversation.ts](file://app\types\conversation.ts#L1-L30)
- [conv-repos.ts](file://app\types\conv-repos.ts#L1-L129) - *新增文件*
- [chat.post.ts](file://server\api\chat.post.ts#L1-L20)
- [ai-gen.ts](file://shared\prompt\ai-gen.ts#L1-L60)

## 架构概览
系统采用前后端分离架构，前端负责用户交互与状态管理，后端处理 AI 请求与业务逻辑，共享模块提供跨层工具与模板。**关键更新**：引入了会话仓库模式，`useChat` 不再直接依赖 `useConversationStore`，而是依赖 `IConversationRepository` 接口，实现了控制反转。

``mermaid
graph LR
Client[前端客户端] --> API[API 接口 /api/chat]
API --> Core[核心处理模块 design-component]
Core --> Prompt[提示模板 ai-gen.ts]
Core --> Utils[服务端工具 format.ts, model.ts]
Core --> |返回结果| API
API --> Client
Client --> Store[Pinia 状态 conversation.ts]
Shared[共享模块] --> Client
Shared --> Core
Client --> Repo[会话仓库 IConversationRepository]
Repo --> Store[PiniaConversationRepository]
```

**图示来源**
- [nuxt.config.ts](file://nuxt.config.ts#L1-L10)
- [chat.post.ts](file://server\api\chat.post.ts#L1-L15)
- [index.ts](file://server\core\steps\design-component\index.ts#L1-L20)
- [useChat.ts](file://app\composables\useChat.ts#L1-L377) - *更新了依赖关系*

## 详细组件分析

### 会话仓库模式
**新增章节**：为支持 `useChat` 的解耦重构，引入了会话仓库模式。该模式定义了一个抽象接口 `IConversationRepository`，并提供了基于 Pinia 的具体实现 `PiniaConversationRepository`。

- **IConversationRepository 接口**：位于 `app/types/conv-repos.ts`，定义了所有会话和消息管理操作的契约，如 `createConversation`、`addMessage`、`updateMessage` 等。这使得 `useChat` 可以面向接口编程，而不关心底层存储实现。
- **PiniaConversationRepository 适配器**：位于 `app/utils/pinia-conv-repos.ts`，实现了 `IConversationRepository` 接口，并将所有调用委托给 `useConversationStore`。这遵循了适配器模式，将现有的 Pinia store 适配到新的接口上。

**本节来源**
- [conv-repos.ts](file://app\types\conv-repos.ts#L1-L129) - *新增文件*
- [pinia-conv-repos.ts](file://app\utils\pinia-conv-repos.ts#L1-L114) - *新增文件*

### 如何新增可组合函数
遵循 `store.ts` 和 `useChat.ts` 的模式，在 `app/composables/` 中创建新文件。**更新**：`useChat` 现在支持依赖注入，这是一个更灵活的模式。

```ts
// 示例：useCustomFeature.ts
import { ref } from 'vue'
import { useConversationStore } from '~/stores/conversation'
import type { IConversationRepository } from '~/types/conv-repos'
import { PiniaConversationRepository } from '~/utils/pinia-conv-repos'

export function useCustomFeature(repository?: IConversationRepository) {
  // 支持依赖注入，优先使用传入的repository
  const repo = repository || new PiniaConversationRepository()
  const data = ref<string>('')

  const processData = (input: string) => {
    // 使用 shared/utils 提升效率
    const id = useId() // 来自 shared/utils/id.ts
    const safeStr = useString().escape(input)
    data.value = `${id}: ${safeStr}`
    // 通过仓库接口操作数据
    if (repo.activeConversation) {
      repo.addMessage(repo.activeConversation.id, {
        id: useId(),
        content: data.value,
        role: 'user',
        timestamp: new Date()
      })
    }
  }

  return { data, processData }
}
```

**本节来源**
- [store.ts](file://app\composables\store.ts#L1-L30)
- [useChat.ts](file://app\composables\useChat.ts#L1-L377) - *更新了函数签名和依赖注入模式*

### 如何利用 shared/utils 工具函数
`shared/utils` 提供高效、可复用的工具函数。

- **id.ts**：`useId()` 生成唯一 ID，用于会话或消息标识。
- **string.ts**：提供字符串格式化、转义、截取等方法。
- **code.ts**：包含代码高亮、语法检查、格式化等辅助功能。

```ts
// 使用示例
import { useId } from 'shared/utils/id'
import { useString } from 'shared/utils/string'
import { useCode } from 'shared/utils/code'

const msgId = useId()
const cleanCode = useString().trim(userInput)
const highlighted = useCode().highlight(cleanCode, 'typescript')
```

**本节来源**
- [id.ts](file://shared\utils\id.ts#L1-L20)
- [string.ts](file://shared\utils\string.ts#L1-L35)
- [code.ts](file://shared\utils\code.ts#L1-L40)

### 如何扩展 prompt 模板
修改或新增 `shared/prompt/` 下的 `.ts` 文件以支持新语言或框架。

```ts
// 示例：扩展 ai-gen.ts 支持 Python
const PYTHON_TEMPLATE = `
你是一个 Python 专家，请根据以下需求生成高质量代码：
{{requirement}}
使用最新 Python 3 特性，添加详细注释。
`

// 在生成逻辑中根据 language 参数选择模板
export function getPrompt(language: string, requirement: string) {
  const base = requirement
  switch (language) {
    case 'python':
      return PYTHON_TEMPLATE.replace('{{requirement}}', base)
    case 'typescript':
    default:
      return TYPESCRIPT_TEMPLATE.replace('{{requirement}}', base)
  }
}
```

**本节来源**
- [ai-gen.ts](file://shared\prompt\ai-gen.ts#L1-L60)
- [template-gen.ts](file://shared\prompt\template-gen.ts#L1-L25)

### 如何添加新的前端组件或后端 API

#### 添加前端组件
1. 在 `app/components/` 创建新 `.vue` 文件。
2. 使用 `<script setup>` 和可组合函数集成逻辑。
3. 在页面中导入并使用。

#### 添加后端 API
1. 在 `server/api/` 创建 `{name}.post.ts`（或其他 HTTP 方法）。
2. 导出默认函数处理请求。
3. 调用核心逻辑或返回数据。

```ts
// server/api/hello.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  return { message: `Hello ${body.name}` }
})
```

**本节来源**
- [CodePreview.vue](file://app\components\CodePreview.vue#L1-L40)
- [chat.post.ts](file://server\api\chat.post.ts#L1-L20)

### 类型安全实践
利用 `types/chat.ts` 和 `types/conversation.ts` 定义接口，确保类型一致性。

```ts
// types/conversation.ts
export interface Conversation {
  id: string
  title: string
  messages: Message[]
  createdAt: number
}

export interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  timestamp: number
}
```

在组件和函数中使用这些类型：

```ts
function addMessage(conv: Conversation, msg: Message) {
  conv.messages.push(msg)
}
```

**本节来源**
- [chat.ts](file://app\types\chat.ts#L1-L40)
- [conversation.ts](file://app\types\conversation.ts#L1-L30)

## 依赖分析
项目依赖关系清晰，模块间耦合度低，便于维护和扩展。**更新**：反映了新的依赖注入模式。

``mermaid
graph TD
A[useChat.ts] --> B[IConversationRepository 接口]
B --> C[PiniaConversationRepository 适配器]
C --> D[conversation.ts Store]
A --> E[chat.ts Types]
A --> F[dependency.ts]
A --> G[id.ts, string.ts]
H[chat.post.ts] --> I[index.ts Core]
I --> J[ai-gen.ts Prompt]
I --> K[format.ts, model.ts]
I --> L[code.ts, string.ts]
M[CodePreview.vue] --> N[highlight.js?]
O[nuxt.config.ts] --> P[全局配置]
```

**图示来源**
- [package.json](file://package.json#L1-L20)
- [nuxt.config.ts](file://nuxt.config.ts#L1-L15)
- [useChat.ts](file://app\composables\useChat.ts#L1-L377) - *更新了依赖关系*

**本节来源**
- [package.json](file://package.json#L1-L50)

## 性能考量
- 前端使用 Nuxt 的服务端渲染（SSR）优化首屏加载。
- 状态管理集中于 Pinia，避免重复计算。
- 服务端逻辑模块化，便于异步处理与缓存。
- 提示模板预编译，减少运行时字符串拼接开销。
- **新增**：会话仓库模式的抽象层开销极小，主要为接口调用，不影响核心性能。

## 故障排除指南
- **API 请求失败**：检查 `server/api/chat.post.ts` 日志，确认 AI 模型服务可用。
- **类型错误**：确保 `types/` 定义与实际数据一致，更新接口后重新构建。
- **ID 冲突**：确认 `useId()` 生成的唯一性，避免手动赋值。
- **提示无效**：调试 `shared/prompt/` 模板变量替换逻辑，确保占位符正确。
- **会话管理异常**：检查 `useChat` 是否正确注入了 `IConversationRepository` 实例，或确认 `PiniaConversationRepository` 是否正确适配了 `useConversationStore`。

**本节来源**
- [chat.post.ts](file://server\api\chat.post.ts#L1-L20)
- [useChat.ts](file://app\composables\useChat.ts#L50-L80)
- [pinia-conv-repos.ts](file://app\utils\pinia-conv-repos.ts#L1-L114) - *新增排查点*

## 结论
本项目结构清晰，模块化程度高，适合二次开发。通过遵循可组合函数模式、利用共享工具、扩展提示模板、遵守类型规范和贡献准则，开发者可高效地定制和扩展功能。**特别强调**：最新的重构引入了会话仓库模式，通过 `IConversationRepository` 接口和依赖注入，显著提升了 `useChat` 的可测试性和可扩展性。建议在开发中始终关注类型安全与代码一致性，以维护项目长期可维护性。