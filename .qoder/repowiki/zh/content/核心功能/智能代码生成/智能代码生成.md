# 智能代码生成

<cite>
**本文档引用的文件**   
- [useChat.ts](file://app/composables/useChat.ts#L1-L365) - *更新了与MCP工具的集成*
- [chat.post.ts](file://server/api/chat.post.ts#L1-L31) - *新增了对mcp-tools的调用*
- [template-gen.ts](file://server/core/prompt/template-gen.ts#L1-L82) - *更新了模板工具说明*
- [mcp-tools.ts](file://server/core/tools/mcp-tools.ts#L1-L33) - *新增的模板工具链*
- [model.ts](file://server/utils/model.ts#L1-L27) - *AI模型配置*
- [index.vue](file://app/pages/chat/index.vue#L1-L726)
- [CodePreview.vue](file://app/components/CodePreview.vue#L1-L82)
</cite>

## 更新摘要
**变更内容**   
- 更新了**核心组件**、**架构概览**和**详细组件分析**中的`chat.post.ts`部分，以反映新增的模板工具链。
- 新增了**模板工具链 (MCP Tools)** 章节，详细说明`mcp-tools.ts`的实现和`template-gen.ts`中`get_template_content`工具的使用。
- 更新了**依赖分析**，将`mcp-tools.ts`和`@modelcontextprotocol/sdk`添加为新的依赖。
- 修正了`template-gen.ts`中关于工具使用的描述，明确指出其通过MCP协议与外部模板服务器交互。
- 所有文件引用和变更说明均已更新，以反映最新的代码状态。

## 目录
1. [项目结构](#项目结构)
2. [核心组件](#核心组件)
3. [架构概览](#架构概览)
4. [详细组件分析](#详细组件分析)
5. [模板工具链 (MCP Tools)](#模板工具链-mcp-tools)
6. [依赖分析](#依赖分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 项目结构
该项目采用分层架构，主要分为前端（app）、服务端（server）和共享模块（shared）。前端使用Nuxt 3框架，包含页面、组合式函数和组件；服务端提供API接口和核心处理逻辑；共享模块存放跨层复用的提示词模板和工具函数。

``mermaid
graph TB
subgraph "前端 (app)"
A[pages/chat/index.vue]
B[composables/useChat.ts]
C[components/CodePreview.vue]
end
subgraph "服务端 (server)"
D[api/chat.post.ts]
E[core/steps/design-component/index.ts]
F[utils/model.ts]
G[core/tools/mcp-tools.ts]
H[core/prompt/template-gen.ts]
end
subgraph "共享 (shared)"
I[prompt/template-gen.ts]
end
A --> B
B --> D
D --> E
D --> H
D --> F
D --> G
G --> H
A --> C
```

**图示来源**
- [app/pages/chat/index.vue](file://app/pages/chat/index.vue#L1-L726)
- [app/composables/useChat.ts](file://app/composables/useChat.ts#L1-L365)
- [server/api/chat.post.ts](file://server/api/chat.post.ts#L1-L31)
- [server/core/steps/design-component/index.ts](file://server/core/steps/design-component/index.ts#L1-L42)
- [shared/prompt/template-gen.ts](file://shared/prompt/template-gen.ts#L1-L82)
- [server/utils/model.ts](file://server/utils/model.ts#L1-L27)
- [server/core/tools/mcp-tools.ts](file://server/core/tools/mcp-tools.ts#L1-L33)

**本节来源**
- [app/pages/chat/index.vue](file://app/pages/chat/index.vue#L1-L726)
- [server/api/chat.post.ts](file://server/api/chat.post.ts#L1-L31)

## 核心组件
核心功能由`useChat.ts`中的`useChat`组合式函数驱动，它管理聊天状态、用户消息和AI响应。`generateResponse`函数是AI代码生成的入口，通过`fetch`调用服务端`/api/chat`接口。服务端`chat.post.ts`接收请求，利用`ai` SDK与SiliconFlow AI服务集成，并初始化MCP（Model Context Protocol）工具链，返回流式响应。`template-gen.ts`提供结构化提示词模板，指导AI生成符合规范的代码。新引入的`mcp-tools.ts`模块负责与外部模板服务器通信，实现动态模板获取。

**本节来源**
- [app/composables/useChat.ts](file://app/composables/useChat.ts#L1-L365)
- [server/api/chat.post.ts](file://server/api/chat.post.ts#L1-L31)
- [server/core/prompt/template-gen.ts](file://server/core/prompt/template-gen.ts#L1-L82)
- [server/core/tools/mcp-tools.ts](file://server/core/tools/mcp-tools.ts#L1-L33)

## 架构概览
系统采用前后端分离架构。前端通过Vue 3组合式API管理状态，用户在聊天界面输入需求后，`useChat`函数触发API请求。服务端`chat.post.ts`作为中间层，初始化MCP工具客户端，将请求转发给SiliconFlow AI服务，并将流式响应返回给前端。AI模型根据`templateGenPrompt`提供的规则和`design-component`模块的结构化要求生成代码，并在需要时通过`get_template_content`工具调用`mcp-tools`从外部服务器获取模板内容。

``mermaid
sequenceDiagram
participant 用户 as "用户"
participant 前端 as "前端 (index.vue)"
participant 组合式函数 as "useChat.ts"
participant API端点 as "chat.post.ts"
participant MCP工具 as "mcp-tools.ts"
participant 模板服务器 as "外部模板服务器"
participant AI服务 as "SiliconFlow AI"
用户->>前端 : 输入“生成一个带图标的按钮”
前端->>组合式函数 : 调用sendMessage()
组合式函数->>组合式函数 : 添加用户消息
组合式函数->>组合式函数 : 创建助手消息占位符
组合式函数->>API端点 : POST /api/chat
API端点->>API端点 : 初始化MCP工具客户端
API端点->>AI服务 : streamText() 请求 (包含tools)
AI服务->>MCP工具 : 调用 get_template_content 工具
MCP工具->>模板服务器 : 执行命令获取模板
模板服务器-->>MCP工具 : 返回模板内容
MCP工具-->>AI服务 : 返回工具调用结果
AI服务-->>API端点 : 流式SSE响应
API端点-->>组合式函数 : 流式响应
组合式函数->>组合式函数 : 解析data : JSON
组合式函数->>组合式函数 : updateAssistantMessage()
组合式函数-->>前端 : 实时更新消息内容
AI服务-->>API端点 : [DONE]
组合式函数->>组合式函数 : 设置done=true
```

**图示来源**
- [app/pages/chat/index.vue](file://app/pages/chat/index.vue#L1-L726)
- [app/composables/useChat.ts](file://app/composables/useChat.ts#L1-L365)
- [server/api/chat.post.ts](file://server/api/chat.post.ts#L1-L31)
- [server/core/tools/mcp-tools.ts](file://server/core/tools/mcp-tools.ts#L1-L33)
- [server/core/prompt/template-gen.ts](file://server/core/prompt/template-gen.ts#L1-L82)

## 详细组件分析
### useChat.ts 分析
该文件是前端逻辑的核心，封装了与AI交互的所有方法。

#### generateResponse 函数流程
``mermaid
flowchart TD
Start([开始 generateResponse]) --> Fetch["调用 fetch('/api/chat')"]
Fetch --> CheckResponse["检查响应状态"]
CheckResponse --> |失败| ThrowError["抛出 HTTP 错误"]
CheckResponse --> |成功| GetReader["获取响应流 reader"]
GetReader --> |失败| ThrowError
GetReader --> Init["初始化 decoder, accumulatedContent"]
Init --> ReadLoop["循环 reader.read()"]
ReadLoop --> IsDone{"done?"}
IsDone --> |否| Decode["解码 chunk"]
Decode --> SplitLines["按 '\\n' 分割行"]
SplitLines --> ProcessLine["遍历每一行"]
ProcessLine --> IsData{"以 'data: ' 开头?"}
IsData --> |否| NextLine["处理下一行"]
IsData --> |是| IsNotDone{"包含 '[DONE]'?"}
IsNotDone --> |是| BreakLoop["跳出循环"]
IsNotDone --> |否| ParseJSON["解析 JSON 数据"]
ParseJSON --> HandleType["根据 data.type 分支处理"]
HandleType --> |text-delta| UpdateContent["accumulatedContent += delta<br/>updateAssistantMessage()"]
HandleType --> |reasoning-delta| UpdateReasoning["reasoningContent += delta<br/>updateMessageReasoning()"]
HandleType --> |其他| Ignore["忽略"]
UpdateContent --> NextLine
UpdateReasoning --> NextLine
NextLine --> ProcessLine
IsDone --> |是| FinalUpdate["updateAssistantMessage(done=true)"]
FinalUpdate --> Return["返回 accumulatedContent"]
```

**图示来源**
- [app/composables/useChat.ts](file://app/composables/useChat.ts#L1-L365)

**本节来源**
- [app/composables/useChat.ts](file://app/composables/useChat.ts#L1-L365)

### chat.post.ts 分析
该文件是服务器端的API入口，负责与AI SDK集成。

#### API请求处理流程
``mermaid
flowchart TD
Request["收到 POST /api/chat 请求"] --> ReadBody["读取请求体"]
ReadBody --> ExtractMessages["提取 messages 数组"]
ExtractMessages --> InitTools["调用 initMcpTools()"]
InitTools --> CreateClient["创建MCP客户端"]
CreateClient --> Connect["连接外部模板服务器"]
Connect --> GetTools["获取工具列表"]
GetTools --> StreamText["调用 streamText()"]
StreamText --> Model["model: siliconflow('Qwen/Qwen3-Coder-30B-A3B-Instruct')"]
StreamText --> System["system: templateGenPrompt()"]
StreamText --> Messages["messages: 从请求体获取"]
StreamText --> Tools["tools: 从initMcpTools获取"]
Model --> |配置| SiliconFlow["SiliconFlow AI 服务"]
System --> |提示词| SiliconFlow
Messages --> |上下文| SiliconFlow
Tools --> |工具| SiliconFlow
SiliconFlow --> |流式SSE| StreamText
StreamText --> ToResponse["toUIMessageStreamResponse()"]
ToResponse --> Response["返回流式HTTP响应"]
```

**图示来源**
- [server/api/chat.post.ts](file://server/api/chat.post.ts#L1-L31)
- [server/core/tools/mcp-tools.ts](file://server/core/tools/mcp-tools.ts#L1-L33)
- [server/core/prompt/template-gen.ts](file://server/core/prompt/template-gen.ts#L1-L82)
- [server/utils/model.ts](file://server/utils/model.ts#L1-L27)

**本节来源**
- [server/api/chat.post.ts](file://server/api/chat.post.ts#L1-L31)

### template-gen.ts 分析
该文件定义了AI生成代码的系统提示词，是确保输出质量的关键。

**提示词结构**
- **角色**: 代码生成器
- **目标**: 解析需求，生成实体代码
- **可用模板**: 列出前后端及数据库脚本的模板类型
- **工作流程**: 7步标准化流程，从需求解析到代码返回
- **关键更新**: 明确指出使用 `get_template_content` 工具通过MCP协议获取模板内容。

此提示词强制AI遵循预设的开发流程，并在需要时调用外部工具获取模板，确保生成的代码符合项目规范。

**本节来源**
- [server/core/prompt/template-gen.ts](file://server/core/prompt/template-gen.ts#L1-L82)

### design-component/index.ts 分析
该模块使用`generateObject`函数，结合Zod模式，从自然语言需求中提取结构化组件设计。

``mermaid
classDiagram
class generateComponentDesign {
+systemPrompt : string
+generateObject() : Promise~Object~
+schema : z.object
}
class z.object {
+componentName : z.string()
+componentDescription : z.string()
+componentBasicFunction : z.string()
+componentStyle : z.string()
}
generateComponentDesign --> z.object : "使用"
generateComponentDesign --> siliconflow : "调用"
```

**图示来源**
- [server/core/steps/design-component/index.ts](file://server/core/steps/design-component/index.ts#L1-L42)

**本节来源**
- [server/core/steps/design-component/index.ts](file://server/core/steps/design-component/index.ts#L1-L42)

## 模板工具链 (MCP Tools)
### mcp-tools.ts 分析
该文件是新增的核心模块，实现了基于Model Context Protocol (MCP) 的模板工具链。

#### 功能概述
`mcp-tools.ts`通过`experimental_createMCPClient`创建一个与外部模板服务器通信的客户端。当AI模型需要获取特定模板时，会调用`get_template_content`工具，该工具通过`StdioClientTransport`执行一个外部命令（`uv run template_mcp`）来启动模板服务器并获取内容。

#### initMcpTools 函数流程
``mermaid
flowchart TD
Start([开始 initMcpTools]) --> CreateClient["调用 experimental_createMCPClient()"]
CreateClient --> Transport["配置 StdioClientTransport"]
Transport --> Command["command: 'uv'"]
Transport --> Args["args: ['--directory', 'E:/GitHub/All_in_Ai/test_mcp_server', 'run', 'template_mcp']"]
CreateClient --> ClientPromise["返回一个Promise<client>"]
ClientPromise --> AwaitTools["await (await clientPromise).tools()"]
AwaitTools --> ReturnTools["返回工具对象"]
```

**本节来源**
- [server/core/tools/mcp-tools.ts](file://server/core/tools/mcp-tools.ts#L1-L33)

## 依赖分析
系统依赖关系清晰，前端依赖服务端API，服务端依赖AI SDK、共享模块和外部工具。`model.ts`是关键的集成点，它使用`@ai-sdk/openai-compatible`创建与SiliconFlow兼容的客户端。`mcp-tools.ts`引入了新的依赖`@modelcontextprotocol/sdk`，用于实现MCP协议通信。

``mermaid
graph LR
A[app/pages/chat/index.vue] --> B[app/composables/useChat.ts]
B --> C[server/api/chat.post.ts]
C --> D[shared/prompt/template-gen.ts]
C --> E[server/utils/model.ts]
E --> F["@ai-sdk/openai-compatible"]
C --> G[server/core/steps/design-component/index.ts]
C --> H[server/core/tools/mcp-tools.ts]
H --> I["@modelcontextprotocol/sdk"]
H --> J["外部模板服务器"]
A --> K[app/components/CodePreview.vue]
K --> L["#shared/utils/code"]
```

**图示来源**
- [nuxt.config.ts](file://nuxt.config.ts#L1-L24)
- [server/utils/model.ts](file://server/utils/model.ts#L1-L27)
- [server/core/tools/mcp-tools.ts](file://server/core/tools/mcp-tools.ts#L1-L33)

**本节来源**
- [server/utils/model.ts](file://server/utils/model.ts#L1-L27)
- [server/core/tools/mcp-tools.ts](file://server/core/tools/mcp-tools.ts#L1-L33)

## 性能考虑
1. **流式传输**: 使用SSE实现逐字输出，提升用户体验，减少等待感。
2. **错误重试**: `useChat.ts`中的`sendMessage`和`regenerate`函数包含完整的try-catch块，确保网络错误或AI服务异常时能优雅降级。
3. **提示词工程**: `template-gen.ts`中的结构化提示词显著提高了AI输出的准确性和一致性。
4. **响应缓存**: 当前未实现，建议在`useChat.ts`中缓存常见问题的响应，避免重复调用AI服务。此外，可考虑在`mcp-tools.ts`中缓存模板内容，减少外部进程调用开销。

## 故障排除指南
- **AI无响应**: 检查`nuxt.config.ts`中的`siliconFlowApiUrl`和`siliconFlowApiKey`是否正确配置。
- **流式中断**: 检查`useChat.ts`中`reader.read()`的循环逻辑，确保正确处理`done`状态。
- **代码生成错误**: 检查`template-gen.ts`的提示词是否清晰，必要时增加更多约束条件。如果涉及模板获取失败，请检查`mcp-tools.ts`中外部命令`uv run template_mcp`是否能在指定目录下成功执行。
- **预览失败**: 确保`CodePreview.vue`中引用的Vue和Element Plus版本与项目一致。

**本节来源**
- [app/composables/useChat.ts](file://app/composables/useChat.ts#L1-L365)
- [nuxt.config.ts](file://nuxt.config.ts#L1-L24)
- [server/core/prompt/template-gen.ts](file://server/core/prompt/template-gen.ts#L1-L82)
- [app/components/CodePreview.vue](file://app/components/CodePreview.vue#L1-L82)
- [server/core/tools/mcp-tools.ts](file://server/core/tools/mcp-tools.ts#L1-L33)

## 结论
该智能代码生成系统实现了从用户需求到可运行代码的完整闭环。前端通过`useChat`组合式函数管理交互，服务端`chat.post`作为AI网关，结合`template-gen`的提示词工程和`design-component`的结构化设计，确保了高质量的代码输出。流式SSE传输和实时更新机制提供了优秀的用户体验。**关键更新**是引入了基于MCP协议的`mcp-tools`模板工具链，使系统能够动态、灵活地从外部服务器获取代码模板，极大地增强了系统的可扩展性和维护性。未来可优化方向包括引入响应缓存、增强错误处理和扩展更多代码模板。