# 核心功能详解

<cite>
**本文档引用的文件**  
- [useChat.ts](file://app/composables/useChat.ts)
- [index.vue](file://app/pages/chat/index.vue)
- [chat.post.ts](file://server/api/chat.post.ts)
- [template-gen.ts](file://server/core/prompt/template-gen.ts)
- [code.ts](file://shared/utils/code.ts)
- [repair-vue.ts](file://shared/utils/repair-vue.ts)
- [ModelSelect.vue](file://app/components/ModelSelect.vue)
- [model.ts](file://server/utils/model.ts)
- [conversation.ts](file://app/stores/conversation.ts)
- [pinia-conv-repos.ts](file://app/utils/pinia-conv-repos.ts)
</cite>

## 目录
1. [聊天交互](#聊天交互)
2. [代码生成](#代码生成)
3. [模型切换](#模型切换)
4. [会话管理](#会话管理)

## 聊天交互

该功能模块由 `useChat.ts` 组合式函数与 `index.vue` 页面组件协同实现，负责用户消息的发送、AI流式响应的接收与重试机制的处理。

### 消息发送流程
用户在聊天界面输入内容后，触发 `handleSendMessage` 方法，该方法调用 `useChat` 提供的 `sendMessage` 函数。该函数首先通过 `addUserMessage` 将用户消息添加至当前会话，并在会话为空时自动创建默认会话并设置标题。随后，调用 `generateResponse` 发起对 `/api/chat` 的 POST 请求，将当前会话的所有消息历史与选定的模型名称发送至后端。

**Section sources**
- [useChat.ts](file://app/composables/useChat.ts#L150-L250)
- [index.vue](file://app/pages/chat/index.vue#L380-L400)

### 流式响应接收
`generateResponse` 函数使用 `fetch` 的流式读取能力（`response.body.getReader()`）处理服务器的逐字输出。它通过 `TextDecoder` 解码数据流，并按行解析以 `data: ` 开头的 Server-Sent Events (SSE) 消息。解析逻辑根据消息的 `type` 字段进行分发：
- `text-delta`: 累积 AI 助手的回复内容，并通过 `updateAssistantMessage` 实时更新前端显示。
- `reasoning-start/delta`: 捕获 AI 的内部推理过程，用于在前端展示“思考中”状态。
- `tool-input/output-available`: 处理工具调用的输入与输出，将其格式化为 Markdown 展示给用户。

此机制确保了用户能够即时看到 AI 的回复过程，而非等待完整响应。

**Section sources**
- [useChat.ts](file://app/composables/useChat.ts#L170-L250)

### 重试机制
`regenerate` 函数实现了消息重试功能。当用户点击“重新生成”按钮时，系统会定位到指定的助手消息，删除该消息及其之后的所有消息（包括可能的用户追问），然后调用 `generateResponse` 重新生成新的回复。这保证了重试基于一个干净的上下文，避免了历史消息的干扰。

**Section sources**
- [useChat.ts](file://app/composables/useChat.ts#L250-L320)
- [index.vue](file://app/pages/chat/index.vue#L405-L425)

## 代码生成

代码生成功能是一个多阶段的流水线，涉及提示词构建、AI输出解析、代码提取与修复等环节。

### 指令构建
后端 API `chat.post.ts` 在接收到请求后，会调用 `templateGenPrompt()` 函数来构建发送给大模型的系统提示词。该提示词（位于 `template-gen.ts`）定义了 AI 的角色为“代码生成引擎”，并详细规定了其工作流程：必须使用 Velocity 模板语法，优先处理 `#[[]]#` 字面量块，完整遍历 `#foreach` 循环，并最终输出纯代码。提示词还根据配置动态包含 Vue2 或 Vue3 的模板列表，确保生成的代码符合前端框架要求。

**Section sources**
- [chat.post.ts](file://server/api/chat.post.ts#L15-L25)
- [template-gen.ts](file://server/core/prompt/template-gen.ts#L1-L238)

### 代码提取与修复
AI 的回复通常包含代码块和解释性文字。`code.ts` 文件中的 `extractCode` 函数负责从回复的 Markdown 内容中提取出 ```vue ``` 包裹的代码片段。提取后，`repair-vue.ts` 中的 `genPreviewCode` 函数对代码进行修复和增强：
1.  **解析结构**：使用 `extractVuePart` 函数精确分离 `<template>`、`<script setup>` 和 `<style>` 部分。
2.  **检测依赖**：`detectUsedVueApis` 扫描代码，识别出使用了哪些 Vue API（如 `ref`, `computed`）。
3.  **修复导入**：检查 `<script setup>` 中是否已导入这些 API。若已导入但不完整，则移除旧的导入语句并生成包含所有必需 API 的新导入；若未导入，则直接添加。这确保了生成的代码在独立运行时不会因缺少导入而报错。

**Section sources**
- [code.ts](file://shared/utils/code.ts#L10-L100)
- [repair-vue.ts](file://shared/utils/repair-vue.ts#L100-L240)

## 模型切换

模型切换功能由前端组件 `ModelSelect.vue` 与后端工具 `model.ts` 共同实现。

### 前端联动
`ModelSelect.vue` 是一个下拉选择器，它使用 `defineModel` 宏与父组件的 `selectedModel` 变量进行双向绑定。当用户从弹出的列表中选择一个模型时，`selectModel` 方法会更新绑定的 `modelValue`，这个变化会立即反映到 `useChat` 组合式函数中的 `selectedModel` 状态上。

**Section sources**
- [ModelSelect.vue](file://app/components/ModelSelect.vue#L50-L80)

### 动态模型选择
后端的 `model.ts` 文件是模型选择的核心。它定义了一个 `AvailableModels` 列表，其中每个模型都指定了其 `id`、`provider`（如 siliconflow, bailian）和 `middleware`。`llmProvider` 函数接收前端传来的模型名称，通过 `createModelProvider` 动态创建一个包含所有可用模型的自定义提供器。该函数根据模型的 `provider` 配置，使用相应的 SDK（如 `createOpenAICompatible`）实例化语言模型。当 `chat.post.ts` 调用 `llmProvider(model)` 时，即可获得对应服务商的模型实例，从而实现动态切换。

**Section sources**
- [model.ts](file://server/utils/model.ts#L50-L120)

## 会话管理

会话管理采用 Pinia 状态管理库，通过 `conversation.ts` 定义 Store，并通过 `pinia-conv-repos.ts` 提供统一的仓库接口。

### Pinia Store 实现
`conversation.ts` 中的 `useConversationStore` 定义了会话的核心状态：`conversations` 数组存储所有会话元数据，`activeConversationId` 标记当前会话，`conversationMessages` Map 以会话 ID 为键存储对应的消息列表。Store 提供了 `createConversation`、`addMessage`、`updateMessage` 等方法来操作这些状态。

**Section sources**
- [conversation.ts](file://app/stores/conversation.ts#L10-L315)

### 本地存储同步
`pinia-conv-repos.ts` 实现了 `IConversationRepository` 接口，它作为 Pinia Store 的适配器，将 Store 的方法暴露为仓库的 API。虽然当前代码未直接展示持久化逻辑（如 `localStorage`），但该设计模式为持久化提供了清晰的入口。`PiniaConversationRepository` 类封装了对 Store 的访问，`useChat` 函数通过依赖注入接收此仓库实例，使得聊天逻辑与状态存储解耦。未来只需在 `PiniaConversationRepository` 的方法中添加 `localStorage` 的读写操作，即可轻松实现会话数据的持久化。

**Section sources**
- [pinia-conv-repos.ts](file://app/utils/pinia-conv-repos.ts#L10-L115)
- [useChat.ts](file://app/composables/useChat.ts#L10-L20)