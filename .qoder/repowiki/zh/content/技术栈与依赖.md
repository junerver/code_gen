# 技术栈与依赖

<cite>
**本文档中引用的文件**   
- [package.json](file://package.json) - *新增自选模型和模板工具依赖*
- [nuxt.config.ts](file://nuxt.config.ts#L1-L11)
- [tsconfig.json](file://tsconfig.json#L1-L18)
- [app/composables/useChat.ts](file://app\composables\useChat.ts#L1-L371) - *新增模型选择功能集成*
- [app/stores/conversation.ts](file://app\stores\conversation.ts#L1-L317)
- [app/types/chat.ts](file://app\types\chat.ts#L1-L20)
- [app/types/conversation.ts](file://app\types\conversation.ts#L1-L78)
- [server/api/chat.post.ts](file://server\api\chat.post.ts#L1-L31) - *集成模板工具*
- [server/utils/model.ts](file://server\utils\model.ts#L1-L27)
- [shared/prompt/template-gen.ts](file://shared\prompt\template-gen.ts#L1-L80) - *模板生成提示词*
- [app/pages/chat/index.vue](file://app\pages\chat\index.vue#L1-L725)
- [app/components/ModelSelect.vue](file://app\components\ModelSelect.vue#L1-L154) - *新增模型选择组件*
- [shared/utils/code.ts](file://shared\utils\code.ts#L1-L394)
- [app/composables/store.ts](file://app\composables\store.ts#L1-L294)
- [app/template/main.vue](file://app\template\main.vue#L1-L9)
- [app/template/element-plus.js](file://app\template\element-plus.js#L1-L10)
- [shared/types/model.ts](file://shared\types\model.ts#L1-L50) - *定义可用模型列表*
- [server/core/tools/mcp-tools.ts](file://server\core\tools\mcp-tools.ts#L1-L32) - *模板工具实现*
</cite>

## 更新摘要
**变更内容**   
- 在核心依赖分析中新增了自选模型功能和模板工具的说明
- 在架构与配置中更新了Nuxt配置以反映新功能
- 在数据流与功能实现中扩展了聊天功能数据流以包含模型选择
- 新增了自选模型功能和模板工具两个独立章节
- 所有文件引用均已更新以反映最新代码状态

## 目录
1. [技术栈概览](#技术栈概览)
2. [核心依赖分析](#核心依赖分析)
3. [架构与配置](#架构与配置)
4. [数据流与功能实现](#数据流与功能实现)
5. [AI集成与提示工程](#ai集成与提示工程)
6. [代码预览与运行环境](#代码预览与运行环境)
7. [状态管理](#状态管理)
8. [类型系统](#类型系统)
9. [自选模型功能](#自选模型功能)
10. [模板工具](#模板工具)

## 技术栈概览

本项目是一个基于Nuxt 4框架的AI代码生成助手，采用现代化的全栈技术组合，实现了从用户界面到后端AI服务的完整集成。项目技术栈以Vue 3为核心，结合TypeScript提供强类型保障，使用Pinia进行状态管理，并通过Element Plus构建现代化UI界面。AI能力通过`@ai-sdk/openai`库集成，支持与多种AI模型的交互。

项目采用Nuxt框架的模块化架构，充分利用其服务端渲染（SSR）和静态生成能力，同时配置为客户端渲染（`ssr: false`）以优化交互体验。整个技术选型体现了对开发效率、类型安全和可维护性的高度重视。

**Section sources**
- [package.json](file://package.json)
- [nuxt.config.ts](file://nuxt.config.ts#L1-L11)

## 核心依赖分析

### 前端框架与UI库
项目基于 **Nuxt 4**（基于Vue 3）构建，这是Vue.js的官方全栈框架，提供了现代化的开发体验和强大的功能集。Nuxt 4带来了更好的TypeScript支持、模块化架构和性能优化。

**Element Plus** 作为UI组件库被选用，它提供了丰富的、高质量的Vue 3组件，极大地加速了UI开发。项目通过 `@element-plus/nuxt` 模块将其无缝集成到Nuxt框架中。

``mermaid
graph TD
A[Nuxt 4] --> B[Vue 3]
A --> C[Element Plus]
C --> D[@element-plus/icons-vue]
C --> E[@element-plus/nuxt]
```

**Diagram sources**
- [package.json](file://package.json)

### 状态管理
**Pinia** 是Vue生态系统中推荐的状态管理库，项目通过 `@pinia/nuxt` 模块将其集成。Pinia提供了简洁的API、TypeScript原生支持和模块化设计，相比Vuex更易于使用和维护。

### AI集成
项目的核心AI能力通过 **`@ai-sdk/openai`** 和 **`@ai-sdk/openai-compatible`** 库实现。这些库提供了统一的API来与各种AI模型交互，支持流式响应（streaming），这对于实现类似打字机效果的AI回复至关重要。

**`ai`** 库是底层支持库，提供了流式处理、工具调用等高级功能。项目还集成了 **`ollama-ai-provider-v2`**，表明其支持本地Ollama服务。

### 新增功能依赖
项目新增了两项重要功能，引入了相应的依赖：

**自选模型功能**：通过 `@modelcontextprotocol/sdk` 库支持，允许用户在多个AI模型之间进行选择。该功能由 `ModelSelect` 组件实现，用户可以从预定义的模型列表中选择最适合当前任务的模型。

**模板工具**：通过 `@modelcontextprotocol/sdk` 和 `ai` 库的 `experimental_createMCPClient` 功能实现，支持模板化代码生成。该工具通过标准输入输出协议与外部模板服务器通信，获取并应用各种代码模板。

### 其他关键依赖
- **`@vueuse/core`** 和 **`@vueuse/nuxt`**: 提供了大量实用的Vue组合式函数，简化了常见功能的实现。
- **`zod`**: 用于运行时类型验证和数据解析。
- **`dayjs`**: 轻量级日期处理库。
- **`vue-element-plus-x`**: 扩展了Element Plus的功能，提供了如 `BubbleList`、`Sender` 等高级组件，用于构建聊天界面。

**Section sources**
- [package.json](file://package.json)

## 架构与配置

### Nuxt配置
`nuxt.config.ts` 文件定义了项目的核心配置：

```typescript
export default defineNuxtConfig({
  ssr: false,
  compatibilityDate: '2025-07-15',
  devtools: { enabled: true },
  modules: ['@nuxt/eslint', '@element-plus/nuxt', '@pinia/nuxt'],
  runtimeConfig: {
    siliconFlowApiUrl: '',
    siliconFlowApiKey: '',
  },
});
```

- **`ssr: false`**: 配置为纯客户端渲染（CSR），适合高度交互的应用。
- **`modules`**: 启用了ESLint、Element Plus和Pinia的Nuxt模块，实现了功能的即插即用。
- **`runtimeConfig`**: 定义了运行时环境变量，用于存储AI服务的API URL和密钥，这些配置在客户端和服务器端都可用，但不会暴露在前端代码中。

``mermaid
classDiagram
class NuxtConfig {
+ssr : boolean
+compatibilityDate : string
+devtools : object
+modules : string[]
+runtimeConfig : object
}
NuxtConfig --> Module : "uses"
Module --> ESLintModule : "@nuxt/eslint"
Module --> ElementPlusModule : "@element-plus/nuxt"
Module --> PiniaModule : "@pinia/nuxt"
```

**Diagram sources**
- [nuxt.config.ts](file://nuxt.config.ts#L1-L11)

### TypeScript配置
项目的 `tsconfig.json` 采用了Nuxt推荐的配置模式，通过引用多个子配置文件来管理不同环境的类型检查：

```json
{
  "files": [],
  "references": [
    { "path": "./.nuxt/tsconfig.app.json" },
    { "path": "./.nuxt/tsconfig.server.json" },
    { "path": "./.nuxt/tsconfig.shared.json" },
    { "path": "./.nuxt/tsconfig.node.json" }
  ]
}
```

这种配置方式确保了应用代码、服务器代码、共享代码和Node.js环境代码都能得到正确的类型检查，同时保持了配置的模块化和可维护性。

**Section sources**
- [tsconfig.json](file://tsconfig.json#L1-L18)

## 数据流与功能实现

### 聊天功能数据流
聊天功能是项目的核心，其数据流涉及多个组件和层的协作。

``mermaid
sequenceDiagram
participant User as "用户"
participant ChatPage as "聊天页面"
participant UseChat as "useChat组合式函数"
participant Store as "会话Store"
participant API as "后端API"
participant AI as "AI模型"
User->>ChatPage : 输入消息并发送
ChatPage->>UseChat : 调用sendMessage(content)
UseChat->>Store : 调用addUserMessage(content)
Store->>Store : 更新messages状态
UseChat->>UseChat : 调用generateResponse()
UseChat->>API : 发送POST /api/chat请求
API->>AI : 调用streamText()与AI交互
AI-->>API : 返回流式数据
API-->>UseChat : 返回流式响应
loop 处理每个数据块
UseChat->>UseChat : 解析data : JSON
UseChat->>Store : 调用updateAssistantMessage(content)
Store->>Store : 更新助手消息内容
end
UseChat-->>ChatPage : 完成响应
ChatPage-->>User : 显示完整回复
```

**Diagram sources**
- [app/pages/chat/index.vue](file://app\pages\chat\index.vue#L1-L725)
- [app/composables/useChat.ts](file://app\composables\useChat.ts#L1-L371)
- [server/api/chat.post.ts](file://server\api\chat.post.ts#L1-L31)

### 组件关系
``mermaid
graph TD
A[ChatPage] --> B[useChat]
A --> C[Conversations]
A --> D[Sender]
A --> E[BubbleList]
A --> F[CodePreview]
B --> G[conversationStore]
G --> H[Pinia]
B --> I[fetch /api/chat]
I --> J[chat.post.ts]
J --> K[streamText]
K --> L[AI Model]
```

**Diagram sources**
- [app/pages/chat/index.vue](file://app\pages\chat\index.vue#L1-L725)
- [app/composables/useChat.ts](file://app\composables\useChat.ts#L1-L371)
- [server/api/chat.post.ts](file://server\api\chat.post.ts#L1-L31)

## AI集成与提示工程

### AI模型集成
`server/utils/model.ts` 文件定义了与SiliconFlow AI服务的集成：

```typescript
export const siliconflow = createOpenAICompatible<...>({
  baseURL: useRuntimeConfig().siliconFlowApiUrl,
  apiKey: useRuntimeConfig().siliconFlowApiKey,
  name: 'siliconflow',
});
```

`createOpenAICompatible` 函数创建了一个兼容OpenAI API格式的客户端，允许项目与任何遵循该标准的AI服务通信。API密钥和URL通过 `runtimeConfig` 安全注入。

### 提示工程
`shared/prompt/template-gen.ts` 文件定义了发送给AI模型的系统提示词。该提示词精心设计，指导AI作为一个代码生成器工作：

- **角色**: 明确AI是"代码生成器"。
- **目标**: 解析需求，生成实体代码。
- **可用模板**: 列出了后端、前端和数据库脚本的可用模板。
- **工作流程**: 定义了7步工作流程，包括解析需求、获取模板、生成代码等。

这个系统提示词是项目智能的核心，它确保了AI生成的代码符合预期的格式和结构。

**Section sources**
- [server/utils/model.ts](file://server\utils\model.ts#L1-L27)
- [shared/prompt/template-gen.ts](file://shared\prompt\template-gen.ts#L1-L80)

## 代码预览与运行环境

### Vue REPL集成
项目通过 `@vue/repl` 库集成了一个在线的Vue代码预览环境。当用户点击"预览组件"按钮时，生成的代码会在一个沙箱环境中实时运行。

`app/components/CodePreview.vue` 组件是预览功能的入口，它使用 `<Repl>` 组件来渲染代码。

### 代码增强
`shared/utils/code.ts` 中的 `genPreviewCode` 函数负责将AI生成的原始代码转换为可预览的格式：

1. **提取代码块**: 使用 `extractCode` 函数从Markdown中提取代码。
2. **解析Vue组件**: 使用 `extractVuePart` 函数分离`<template>`、`<script>`和`<style>`部分。
3. **自动导入**: 分析代码中使用的Vue API（如`ref`、`computed`），并自动在`<script setup>`中添加相应的`import` 语句。
4. **构建完整组件**: 将处理后的各部分重新组合成一个完整的Vue单文件组件（SFC）。

### 运行环境构建
为了确保预览环境的正确性，项目构建了完整的运行时：

- **`buildElementPlusSetup`**: 动态生成Element Plus的初始化代码，通过CDN加载CSS。
- **`buildPlaygroundMain`**: 创建一个主应用组件，导入并使用App组件。
- **`generateImportMap`**: 生成一个`import-map.json`文件，定义了所有依赖（如Vue、Element Plus）的CDN链接，使浏览器能正确解析模块。

``mermaid
flowchart TD
A[AI生成的代码] --> B[extractCode]
B --> C[原始代码字符串]
C --> D[genPreviewCode]
D --> E[分离template/script/style]
D --> F[检测使用的Vue API]
D --> G[生成import语句]
D --> H[构建完整SFC]
H --> I[设置Repl的files]
I --> J[Vue REPL渲染]
J --> K[用户预览]
```

**Diagram sources**
- [app/components/CodePreview.vue](file://app\components\CodePreview.vue#L1-L154)
- [shared/utils/code.ts](file://shared\utils\code.ts#L1-L394)

## 状态管理

### 会话Store
`app/stores/conversation.ts` 文件定义了使用Pinia的 `useConversationStore`。该Store管理了所有会话的状态：

- **状态 (State)**:
  - `conversations`: 会话列表。
  - `activeConversationId`: 当前活跃会话的ID。
  - `conversationMessages`: 一个Map，存储每个会话ID对应的消息列表。
- **计算属性 (Getters)**:
  - `activeConversation`: 根据ID获取当前会话。
  - `activeMessages`: 获取当前会话的消息列表。
- **方法 (Actions)**:
  - `createConversation`, `updateConversation`, `deleteConversation`: 会话的CRUD操作。
  - `addMessage`, `updateMessage`: 消息的增改操作。
  - `clearMessages`: 清空会话。

该Store的设计体现了清晰的单一职责原则，所有与会话相关的状态和逻辑都集中于此。

### 聊天组合式函数
`app/composables/useChat.ts` 是一个组合式函数，它封装了聊天功能的业务逻辑，并依赖于 `conversationStore`。

- **状态**: 通过计算属性从Store中获取 `messages` 和 `activeConversation`。
- **方法**: `sendMessage`, `regenerate`, `clearMessages` 等，这些方法调用Store的方法来修改状态，并处理与后端API的交互。

这种分层设计（Store负责状态，Composable负责业务逻辑）使得代码结构清晰，易于测试和维护。

``mermaid
classDiagram
class useConversationStore {
+conversations : Conversation[]
+activeConversationId : string
+conversationMessages : Map<string, ChatMessage[]>
+loading : boolean
+error : string | undefined
+createConversation()
+updateConversation()
+deleteConversation()
+addMessage()
+updateMessage()
+clearMessages()
}
class useChat {
+messages : ComputedRef<ChatMessage[]>
+activeConversation : ComputedRef<Conversation | undefined>
+loading : Ref<boolean>
+error : Ref<string | undefined>
+sendMessage()
+regenerate()
+clearMessages()
}
useChat --> useConversationStore : "依赖"
```

**Section sources**
- [app/stores/conversation.ts](file://app\stores\conversation.ts#L1-L317)
- [app/composables/useChat.ts](file://app\composables\useChat.ts#L1-L371)

## 类型系统

项目充分利用了TypeScript的类型系统来保证代码的健壮性。

### 核心类型定义
- **`ChatMessage`** (`app/types/chat.ts`): 定义了聊天消息的结构，包括`id`、`content`、`role`（user/assistant）、`timestamp`等。它还扩展了`BubbleProps`，以支持UI组件的特定属性。
- **`Conversation`** (`app/types/conversation.ts`): 定义了会话的结构，包括`id`、`title`、`createdAt`、`updatedAt`和可选的`config`（包含模型、温度等AI参数）。

### 类型安全优势
通过这些类型定义，项目在多个层面获得了类型安全：
- **编译时检查**: 在开发阶段就能发现类型错误。
- **IDE智能提示**: 提供了优秀的开发体验。
- **文档化**: 类型本身就是一种文档，清晰地描述了数据结构。

**Section sources**
- [app/types/chat.ts](file://app\types\chat.ts#L1-L20)
- [app/types/conversation.ts](file://app\types\conversation.ts#L1-L78)

## 自选模型功能

### 功能概述
项目新增了自选模型功能，允许用户在多个AI模型之间进行选择，以适应不同的任务需求。该功能通过 `ModelSelect` 组件实现，用户可以在聊天界面中选择最适合当前任务的AI模型。

### 组件实现
`app/components/ModelSelect.vue` 组件实现了模型选择的UI界面：

- **UI设计**: 使用Element Plus的 `el-popover` 组件创建一个下拉式选择器，显示所有可用的AI模型。
- **模型列表**: 通过 `AvailableModels` 常量获取预定义的模型列表，每个模型包含ID、名称和描述。
- **状态管理**: 使用 `defineModel` 宏实现双向绑定，将选中的模型ID同步到父组件。

```vue
<template>
  <div class="model-select">
    <el-popover
      v-model:visible="showPopover"
      placement="bottom-start"
      :width="400"
      trigger="click"
      popper-class="model-select-popover"
    >
      <template #reference>
        <el-button class="model-select-trigger" :icon="ArrowDown">
          {{ selectedModelDisplay || '选择模型' }}
        </el-button>
      </template>

      <div class="model-popover-content">
        <div class="model-header">
          <span class="model-title">选择AI模型</span>
        </div>

        <div class="model-list">
          <div
            v-for="model in AvailableModels"
            :key="model.id"
            class="model-item"
            :class="{ active: modelValue === model.id }"
            @click="selectModel(model.id)"
          >
            <div class="model-info">
              <div class="model-name">{{ model.name }}</div>
              <div class="model-description">{{ model.description }}</div>
            </div>
            <el-icon v-if="modelValue === model.id" class="check-icon">
              <Check />
            </el-icon>
          </div>
        </div>
      </div>
    </el-popover>
  </div>
</template>
```

### 模型配置
可用模型列表在 `shared/types/model.ts` 中定义：

```typescript
export const AvailableModels: ModelOption[] = [
  {
    id: 'deepseek-ai/DeepSeek-R1',
    name: 'DeepSeek-R1',
    description: '最新推理模型，擅长数学和编程',
  },
  {
    id: 'deepseek-ai/DeepSeek-V3.1',
    name: 'DeepSeek-V3.1',
    description: '通用对话模型，平衡性能优秀',
  },
  {
    id: 'Qwen/Qwen2.5-72B-Instruct-128K',
    name: 'Qwen2.5-72B',
    description: '大参数模型，支持128K上下文',
  },
  {
    id: 'Qwen/Qwen3-Coder-480B-A35B-Instruct',
    name: 'Qwen3-Coder-480B',
    description: '专业代码生成模型，超大参数',
  },
  {
    id: 'Qwen/Qwen3-Coder-30B-A3B-Instruct',
    name: 'Qwen3-Coder-30B',
    description: '轻量级代码生成模型',
  },
];
```

### 集成与使用
`useChat` 组合式函数集成了模型选择功能：

- **状态定义**: 定义了 `selectedModel` 响应式变量，初始值为默认模型。
- **API调用**: 在 `generateResponse` 方法中，将选中的模型ID作为参数传递给后端API。

```typescript
const selectedModel = ref<SiliconflowChatModelIds>(
  'Qwen/Qwen3-Coder-30B-A3B-Instruct'
);

const generateResponse = async (
  assistantMessageId: string
): Promise<string> => {
  const response = await fetch('/api/chat', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: selectedModel.value || 'Qwen/Qwen3-Coder-30B-A3B-Instruct',
      messages: messages.value.map(msg => ({
        role: msg.role,
        content: msg.content,
      })),
    }),
  });
  // ... 处理响应
};
```

**Section sources**
- [app/components/ModelSelect.vue](file://app\components\ModelSelect.vue#L1-L154)
- [shared/types/model.ts](file://shared\types\model.ts#L1-L50)
- [app/composables/useChat.ts](file://app\composables\useChat.ts#L1-L371)

## 模板工具

### 功能概述
项目新增了模板工具功能，通过Model Context Protocol (MCP) 实现与外部模板服务器的集成。该工具允许AI模型在生成代码时使用预定义的模板，确保生成的代码符合项目规范和最佳实践。

### 工具实现
`server/core/tools/mcp-tools.ts` 文件实现了模板工具的初始化：

```typescript
import { experimental_createMCPClient } from 'ai';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';

/**
 * 模板工具
 */
const templateClientPromise = experimental_createMCPClient({
  transport: new StdioClientTransport({
    command: 'uv',
    args: [
      '--directory',
      'E:/GitHub/All_in_Ai/test_mcp_server',
      'run',
      'template_mcp',
    ],
  }),
});

export const initMcpTools = async () => {
  const templateTools = await (await templateClientPromise).tools();
  return {
    ...templateTools,
  };
};
```

- **MCP客户端**: 使用 `experimental_createMCPClient` 创建一个MCP客户端，通过标准输入输出协议与外部服务器通信。
- **传输层**: 使用 `StdioClientTransport` 作为传输层，启动一个外部进程来运行模板服务器。
- **工具初始化**: `initMcpTools` 函数异步获取模板工具列表，并将其返回供AI模型使用。

### 集成与使用
`server/api/chat.post.ts` 文件将模板工具集成到聊天API中：

```typescript
export default defineLazyEventHandler(async () => {
  // 初始化mcp工具
  const tools = await initMcpTools();
  return defineEventHandler(async (event: any) => {
    const { messages, model } = await readBody(event);
    const result = streamText({
      model: siliconflow(model),
      tools,
      stopWhen: stepCountIs(10),
      system: templateGenPrompt(),
      messages,
    });

    return result.toUIMessageStreamResponse();
  });
});
```

- **工具注入**: 在 `streamText` 调用中将 `tools` 作为参数传递，使AI模型能够调用模板工具。
- **提示词配合**: `templateGenPrompt` 提示词指导AI模型如何使用 `get_template_content` 工具获取模板内容。

### 模板工作流程
AI模型使用模板工具的工作流程如下：
1. 解析用户需求，确定需要生成的代码类型。
2. 调用 `get_template_content` 工具，传入模板名称获取模板内容。
3. 根据用户需求和数据库结构，填充模板中的占位符。
4. 生成最终的代码并返回给用户。

**Section sources**
- [server/core/tools/mcp-tools.ts](file://server\core\tools\mcp-tools.ts#L1-L32)
- [server/api/chat.post.ts](file://server\api\chat.post.ts#L1-L31)
- [shared/prompt/template-gen.ts](file://shared\prompt\template-gen.ts#L1-L80)